{
  "fileTypes": [
    "adoc",
    "ad",
    "asciidoc"
  ],
  "name": "AsciiDoc (Asciidoctor)",
  "patterns": [
    {
      "include": "#lists"
    },
    {
      "include": "#blocks"
    },
    {
      "include": "#section_titles"
    },
    {
      "include": "#lines"
    },
    {
      "include": "#inline"
    },
    {
      "include": "#characters"
    }
  ],
  "repository": {
    "attribute_entry": {
      "begin": "(?x)\r\r\n^(:)                          # opening delimiter\r\r\n(!)?                          # bang symbol (unset attribute)\r\r\n([A-Za-z0-9_][A-Za-z0-9_-]*)  # attribute name\r\r\n(!)?                          # bang symbol (unset attribute)\r\r\n(:)                           # closing delimiter (?:\\s+|(?=$))",
      "beginCaptures": {
        "1": {
          "name": "punctuation.definition.attributeentry.attrname.begin.asciidoc"
        },
        "2": {
          "name": "punctuation.definition.attributeentry.unset.asciidoc"
        },
        "3": {
          "name": "support.variable.attribute.asciidoc"
        },
        "4": {
          "name": "punctuation.definition.attributeentry.unset.asciidoc"
        },
        "5": {
          "name": "punctuation.definition.attributeentry.attrname.end.asciidoc"
        }
      },
      "comment": "An attribute entry.\r\r\n\r\r\nExamples:\r\r\n  :my-attribute: value\r\r\n  :sectnums!:\r\r\n  :!sectnums:\r\r\n\t\t\t\t",
      "contentName": "meta.attributeentry.value.asciidoc",
      "end": "$\\n?",
      "name": "meta.attributeentry.asciidoc",
      "patterns": [
        {
          "include": "#characters"
        }
      ]
    },
    "attribute_list_line": {
      "captures": {
        "1": {
          "name": "punctuation.definition.attributelistline.begin.asciidoc"
        },
        "2": {
          "name": "punctuation.definition.attributelistline.end.asciidoc"
        }
      },
      "comment": "Attribute list as paragraph: single brackets. No need for special treatment of escape; follows literal block, section template as being a more general regex.\r\r\n\t\t\t\t",
      "match": "^(\\[)[^\\[\\]]*(\\])\\s*$\\n?",
      "name": "support.variable.attributelist.asciidoc"
    },
    "attribute_reference": {
      "captures": {
        "1": {
          "name": "constant.character.attributes.reference.begin.asciidoc"
        },
        "2": {
          "name": "support.variable.attribute.asciidoc"
        },
        "3": {
          "name": "constant.character.attributes.reference.end.asciidoc"
        }
      },
      "comment": "Examples:\r\r\n  {my-attribute}\r\r\n\t\t\t\t",
      "match": "({)([A-Za-z0-9_][A-Za-z0-9_-]*)(})",
      "name": "variable.other"
    },
    "biblio_anchor": {
      "captures": {
        "1": {
          "name": "punctuation.definition.biblioanchor.begin.asciidoc"
        },
        "2": {
          "name": "punctuation.definition.biblioanchor.end.asciidoc"
        }
      },
      "comment": "Bibliography anchor\r\r\n\r\r\nExamples:\r\r\n  [[[Lorem ipsum]]]\r\r\n\t\t\t\t",
      "match": "(?<!\\[)(\\[\\[\\[).*?(\\]\\]\\])(?!\\])",
      "name": "storage.type.reference.biblioanchor.asciidoc"
    },
    "block_admonition_label": {
      "comment": "Label of an admonition block.\r\r\n\r\r\nExamples:\r\r\n  NOTE: This is a admonition block.\r\r\n  WARNING:  Be aware of them!\r\r\n\t\t\t\t",
      "match": "^(NOTE|TIP|IMPORTANT|WARNING|CAUTION):(?=\\s+)",
      "name": "support.constant.admonitionword.asciidoc"
    },
    "block_comment": {
      "begin": "^(/{4,})\\s*$\\n?",
      "beginCaptures": {
        "0": {
          "name": "punctuation.definition.comment.begin.asciidoc"
        }
      },
      "comment": "Examples:\r\r\n  ////\r\r\n  A multi-line comment.\r\r\n  Notice it's a delimited block.\r\r\n  ////\r\r\n\t\t\t\t",
      "contentName": "meta.block.comment.content.asciidoc",
      "end": "^\\1\\s*$\\n?",
      "endCaptures": {
        "0": {
          "name": "punctuation.definition.comment.end.asciidoc"
        }
      },
      "name": "comment.block.asciidoc",
      "patterns": [
        {
          "include": "#macro"
        }
      ]
    },
    "block_example": {
      "begin": "^(={4,})\\s*$\\n?",
      "beginCaptures": {
        "0": {
          "name": "constant.delimiter.example.begin.asciidoc"
        }
      },
      "comment": "Examples:\r\r\n  ====\r\r\n  Lorem ipsum.\r\r\n  ====\r\r\n\r\r\nNote: Might need to add more includes, but these are the ones that arise in\r\r\npractice for me.\r\r\n\t\t\t\t",
      "contentName": "meta.block.example.content.asciidoc",
      "end": "^\\1\\s*$\\n?",
      "endCaptures": {
        "0": {
          "name": "constant.delimiter.example.end.asciidoc"
        }
      },
      "name": "string.unquoted.block.example.asciidoc",
      "patterns": [
        {
          "include": "#lists"
        },
        {
          "include": "#block_listing"
        },
        {
          "include": "#lines"
        },
        {
          "include": "#inline"
        },
        {
          "include": "#characters"
        }
      ]
    },
    "block_id": {
      "captures": {
        "1": {
          "name": "punctuation.definition.blockid.begin.asciidoc"
        },
        "2": {
          "name": "markup.underline.blockid.id.asciidoc"
        },
        "3": {
          "name": "punctuation.definition.blockid.end.asciidoc"
        }
      },
      "comment": "A block id (i.e. anchor).\r\r\n\r\r\nExamples:\r\r\n  [[myid]]\r\r\n  Lorem ipsum dolor.\r\r\n\t\t\t\t",
      "match": "^(\\[\\[)([^\\[].*)(\\]\\])\\s*$\\n?",
      "name": "meta.tag.blockid.asciidoc"
    },
    "block_listing": {
      "begin": "^(\\-{4,})\\s*$\\n?",
      "beginCaptures": {
        "0": {
          "name": "markup.underline.listing.begin.asciidoc"
        }
      },
      "comment": "Examples:\r\r\n  ----\r\r\n  Lorem ipsum.\r\r\n  ----\r\r\n\t\t\t\t",
      "contentName": "source.block.listing.content.asciidoc",
      "end": "^\\1\\s*$\\n?",
      "endCaptures": {
        "0": {
          "name": "markup.underline.listing.end.asciidoc"
        }
      },
      "name": "meta.embedded.block.listing.asciidoc",
      "patterns": [
        {
          "include": "#inline_callout"
        }
      ]
    },
    "block_literal": {
      "begin": "^(\\.{4,})\\s*$\\n?",
      "beginCaptures": {
        "0": {
          "name": "constant.delimiter.block.literal.begin.asciidoc"
        }
      },
      "comment": "Examples:\r\r\n  ....\r\r\n  Lorem ipsum.\r\r\n  ....\r\r\n\t\t\t\t",
      "contentName": "meta.block.literal.content.asciidoc",
      "end": "^\\1\\s*$\\n?",
      "endCaptures": {
        "0": {
          "name": "constant.delimiter.block.literal.end.asciidoc"
        }
      },
      "name": "string.literal.block.delimited.asciidoc",
      "patterns": [
        {
          "include": "#inline_callout"
        }
      ]
    },
    "block_open": {
      "begin": "^\\-\\-\\s*$\\n?",
      "beginCaptures": {
        "0": {
          "name": "markup.underline.block.open.begin.asciidoc"
        }
      },
      "comment": "Examples:\r\r\n  --\r\r\n  Lorem ipsum\r\r\n  --\r\r\nNote: Might need to check on these includes.\r\r\n\t\t\t\t",
      "contentName": "meta.block.open.content.asciidoc",
      "end": "^\\-\\-\\s*$\\n?",
      "endCaptures": {
        "0": {
          "name": "markup.underline.block.open.begin.asciidoc"
        }
      },
      "name": "meta.block.open.asciidoc",
      "patterns": [
        {
          "include": "#lists"
        },
        {
          "include": "#block_comment"
        },
        {
          "include": "#block_listing"
        },
        {
          "include": "#block_pass"
        },
        {
          "include": "#lines"
        },
        {
          "include": "#inline"
        },
        {
          "include": "#characters"
        }
      ]
    },
    "block_page_break": {
      "comment": "A page break.\r\r\n\r\r\nExamples:\r\r\n  <<<\r\r\n  <<<<<\r\r\n\t\t\t\t",
      "match": "^<{3,}$\\n?",
      "name": "meta.separator.pagebreak.asciidoc"
    },
    "block_pass": {
      "begin": "^(\\+{4,})\\s*$\\n?",
      "beginCaptures": {
        "0": {
          "name": "markup.underline.block.passthrough.begin.asciidoc"
        }
      },
      "contentName": "text.xml.block.passthrough.content.asciidoc",
      "end": "^\\1\\s*$\\n?",
      "endCaptures": {
        "0": {
          "name": "markup.underline.block.passthrough.end.asciidoc"
        }
      },
      "name": "meta.embedded.block.passthrough.asciidoc",
      "patterns": [
        {
          "include": "text.xml"
        }
      ]
    },
    "block_quote": {
      "begin": "^(_{4,})\\s*$\\n?",
      "beginCaptures": {
        "0": {
          "name": "constant.delimiter.block.quote.begin.asciidoc"
        }
      },
      "comment": "Examples:\r\r\n  ____\r\r\n  Lorem ipsum\r\r\n  ____\r\r\n\r\r\nNote: Might need to add more includes, but these are the ones that arise for me in practice.\r\r\n\t\t\t\t",
      "contentName": "meta.block.quote.content.asciidoc",
      "end": "^\\1\\s*$\\n?",
      "endCaptures": {
        "0": {
          "name": "constant.delimiter.block.quote.end.asciidoc"
        }
      },
      "name": "markup.quote.block.asciidoc",
      "patterns": [
        {
          "include": "#lines"
        },
        {
          "include": "#inline"
        },
        {
          "include": "#characters"
        }
      ]
    },
    "block_req": {
      "captures": {
        "1": {
          "name": "markup.underline.block.id.asciidoc"
        },
        "3": {
          "name": "variable.parameter.reqid.id.asciidoc"
        },
        "4": {
          "name": "markup.underline.block.version.asciidoc"
        },
        "6": {
          "name": "variable.parameter.reqversion.id.asciidoc"
        },
        "7": {
          "name": "markup.underline.block.id.asciidoc"
        }
      },
      "comment": "A requirement id (i.e. anchor).\r\r\nExamples: [req,id=ROPR1234,version=1]\r\r\n  Lorem ipsum dolor.\r\r\n\t\t\t\t",
      "match": "(\\[req,(\\s+)?id=)(.+?)(,(\\s+)?version=)([0-9])(\\])",
      "name": "meta.tag.blockid.req.asciidoc"
    },
    "block_sidebar": {
      "begin": "^(\\*{4,})\\s*$\\n?",
      "beginCaptures": {
        "0": {
          "name": "constant.delimiter.block.sidebar.begin.asciidoc"
        }
      },
      "comment": "Examples:\r\r\n  ****\r\r\n  Lorem ipsum\r\r\n  ****\r\r\n\r\r\nNote: Might need to add more includes, but these are the ones that arise\r\r\nfor me in practice.\r\r\n\t\t\t\t",
      "contentName": "meta.block.sidebar.content.asciidoc",
      "end": "^\\1\\s*$\\n?",
      "endCaptures": {
        "0": {
          "name": "constant.delimiter.block.sidebar.end.asciidoc"
        }
      },
      "name": "string.quoted.block.sidebar.asciidoc",
      "patterns": [
        {
          "include": "#lists"
        },
        {
          "include": "#block_comment"
        },
        {
          "include": "#block_listing"
        },
        {
          "include": "#lines"
        },
        {
          "include": "#inline"
        },
        {
          "include": "#characters"
        }
      ]
    },
    "block_source_fenced": {
      "begin": "^(```)(\\w+)?\\s*$\\n?",
      "beginCaptures": {
        "0": {
          "name": "constant.delimiter.listing.begin.asciidoc"
        }
      },
      "comment": "Fenced code block (ala Markdown)\r\r\n\r\r\nExamples:\r\r\n  ```rb\r\r\n  puts 'Hello world!'\r\r\n  ```\r\r\n\t\t\t\t",
      "contentName": "source.block.listing.content.asciidoc",
      "end": "^\\1\\s*$\\n?",
      "endCaptures": {
        "0": {
          "name": "constant.delimiter.listing.end.asciidoc"
        }
      },
      "name": "meta.embedded.block.listing.asciidoc",
      "patterns": [
        {
          "include": "#inline_callout"
        }
      ]
    },
    "block_thematic_break": {
      "comment": "A thematic break (aka horizontal rule).\r\r\n\r\r\nExamples:\r\r\n  '''\r\r\n  ''''''\r\r\n\t\t\t\t",
      "match": "^'{3,}$\\n?",
      "name": "meta.separator.ruler.asciidoc"
    },
    "block_title": {
      "comment": "Title of a block. Exludes custom block titles for better\r\r\nscoping / preventing overlap.\r\r\n\r\r\nExamples:\r\r\n  .My title\r\r\n  Lorem ipsum dolor.\r\r\n\t\t\t\t",
      "match": "^(\\.)\\w.*$\\n?",
      "name": "markup.heading.block.asciidoc"
    },
    "blocks": {
      "patterns": [
        {
          "include": "#block_image"
        },
        {
          "include": "#block_literal"
        },
        {
          "include": "#block_comment"
        },
        {
          "include": "#custom_block"
        },
        {
          "include": "#block_listing"
        },
        {
          "include": "#block_source_fenced"
        },
        {
          "include": "#block_sidebar"
        },
        {
          "include": "#block_pass"
        },
        {
          "include": "#block_quote"
        },
        {
          "include": "#block_example"
        },
        {
          "include": "#block_open"
        }
      ]
    },
    "characters": {
      "patterns": [
        {
          "include": "#attribute_reference"
        },
        {
          "include": "#entity_number"
        },
        {
          "include": "#entity_name"
        },
        {
          "include": "#escape"
        },
        {
          "include": "#replacement"
        },
        {
          "include": "#macro_pass"
        },
        {
          "include": "#macro"
        },
        {
          "include": "#xref"
        },
        {
          "include": "#biblio_anchor"
        },
        {
          "include": "#indexterm_triple"
        },
        {
          "include": "#indexterm_double"
        }
      ]
    },
    "colist_item_marker": {
      "captures": {
        "1": {
          "name": "string.unquoted.list.callout.asciidoc"
        },
        "2": {
          "name": "constant.numeric.callout.asciidoc"
        },
        "3": {
          "name": "punctuation.definition.calloutlistnumber.begin.asciidoc"
        },
        "4": {
          "name": "punctuation.definition.calloutlistnumber.end.asciidoc"
        }
      },
      "comment": "Marker of a callout list item.\r\r\n\r\r\nExamples:\r\r\n  <1> a callout\r\r\n<42> another callout\r\r\n\t\t\t\t",
      "match": "^(\\s*((    <)\\d+?(>)))\\s+(?=\\S)",
      "name": "markup.list.numbered.callout.asciidoc"
    },
    "custom_block": {
      "captures": {
        "1": {
          "name": "markup.underline.block.asciidoc"
        },
        "2": {
          "name": "markup.underline.block.asciidoc"
        },
        "3": {
          "name": "variable.parameter.sourcelang.asciidoc"
        },
        "4": {
          "name": "markup.underline.block.asciidoc"
        }
      },
      "match": "(?x)^\r\r\n(\\[)\r\r\n(sect\\d|def|math|TODO|quote|example|source,?(\\w+))\r\r\n(\\s*\\])\r\r\n\\s*$\\n?\r\r\n\t\t\t\t",
      "name": "markup.underline.block.id.def.asciidoc"
    },
    "block_image": {
      "begin": "(^image::)",
      "beginCaptures": {
        "0": {
          "name": "hmm"
        }
      },
      "comment": "Example:\r\r\nimage::filename.ext[alt-text]\r\r\n\t\t\t\t",
      "contentName": "hmm1",
      "end": "($)",
      "endCaptures": {
        "0": {
          "name": "hmm2"
        }
      },
      "name": "hmm3",
      "patterns": [
        {
          "include": "#main__1"
        }
      ]
    },
    'main__1' : {
    'patterns' : [
      {
        'begin' : '(\\[)'
        'beginCaptures' : {
          '1' : {
            'name' : 'text.mysample'
          }
        }
        'contentName' : 'comment.mysample'
        'end' : '(\\]\\s*$)'
        'endCaptures' : {
          '1' : {
            'name' : 'text.mysample'
          }
        }
      }
    ]
  }
    "dlist_item_label": {
      "begin": "^\\s*(?=.*:{2,4}(?:\\s|$))",
      "comment": "Label of a definition (labeled) list item.\r\r\n\r\r\nExamples:\r\r\n  Label level 1:: lorem ipsum\r\r\n  Label level 2::: dolor sit amet\r\r\n  Label level 3:::: consectetur\r\r\n  Label level 1::\r\r\n    lorem ipsum\r\r\n  Another label :: lorem ipsum\r\r\n  Last::label:: dolor sit amet\r\r\n\r\r\nNote: This rule is not strictly correct, because Asciidoctor allows\r\r\ndouble colon followed by a space inside a label, i.e. it matches the\r\r\n*last* double colon, not the first. I don't know how to do that\r\r\n*effectively.\r\r\n\t\t\t\t",
      "contentName": "meta.list.label.asciidoc",
      "end": "(:{2,4})(?:\\s|$\\n?)",
      "endCaptures": {
        "1": {
          "name": "constant.labeledlist.separator.asciidoc"
        }
      },
      "name": "markup.list.labeled.asciidoc",
      "patterns": [
        {
          "include": "#inline"
        },
        {
          "include": "#characters"
        }
      ]
    },
    "emphasis": {
      "captures": {
        "1": {
          "name": "support.variable.attributelist.asciidoc"
        },
        "2": {
          "name": "punctuation.definition.italic.single.begin.asciidoc"
        },
        "3": {
          "name": "punctuation.definition.italic.single.end.asciidoc"
        }
      },
      "comment": "Emphasized (italic) text (constrained variant).\r\r\n\r\r\nExamples:\r\r\n  _Lorem ipsum_ dolor\r\r\n  [red]_Lorem ipsum_ dolor\r\r\n\t\t\t\t",
      "match": "(?!_{4,}\\s*$)(?        <=^|[^\\p{Word};:])(\\[(?:[^\\]]+?)\\])?((_)(\\S|\\S.*?\\S)(_))(?!\\p{Word})",
      "name": "markup.italic.single.asciidoc"
    },
    "emphasis_double": {
      "captures": {
        "1": {
          "name": "support.variable.attributelist.asciidoc"
        },
        "2": {
          "name": "punctuation.definition.italic.double.begin.asciidoc"
        },
        "3": {
          "name": "punctuation.definition.italic.double.end.asciidoc"
        }
      },
      "comment": "Emphasized (italic) text (unconstrained variant).\r\r\n\r\r\nExamples:\r\r\n  Lo__re__m __ipsum dolor__.\r\r\n  Lo[red]__re__m\r\r\n\t\t\t\t",
      "match": "(?<!\\\\\\\\)(\\[(?:[^\\]]+?)\\])?((__)((?!_).+?)(__))",
      "name": "markup.italic.double.asciidoc"
    },
    "entity_name": {
      "comment": "Character entity reference\r\r\n\r\r\nExamples:\r\r\n  &nbsp;\r\r\n  &sup2;\r\r\n\t\t\t\t",
      "match": "(?<!\\\\)&([a-zA-Z][a-zA-Z0-9]*);",
      "name": "constant.character.entity.xml.asciidoc"
    },
    "entity_number": {
      "comment": "Numeric character reference\r\r\n\r\r\nExamples:\r\r\n  &#x278a;\r\r\n  &#182;\r\r\n\t\t\t\t",
      "match": "(?<!\\\\)&#(x?[0-9a-fA-f]{2,4});",
      "name": "constant.character.entity.asciidoc"
    },
    "escape": {
      "comment": "List of special characters that may be escaped.\r\r\n\r\r\nNote: I do not really know if this is a good list, adopted wholesale from\r\r\noriginal bundle.\r\r\n\t\t\t\t",
      "match": "\\\\(?=[-`*_#+.!(){}\\[\\]\\\\>:])",
      "name": "constant.character.escape.asciidoc"
    },
    "indexterm_double": {
      "captures": {
        "1": {
          "name": "constant.character.indexterm.double.begin.asciidoc"
        },
        "3": {
          "name": "constant.character.indexterm.double.end.asciidoc"
        }
      },
      "comment": "Double parenthesis indexterm.\r\r\n\r\r\nExamples:\r\r\n  ((Arthur))\r\r\n\t\t\t\t",
      "match": "(?<!\\()(\\({2})([^\\(\\s].*?)(\\){2})(?!\\))",
      "name": "variable.other.indexterm.double.asciidoc"
    },
    "indexterm_triple": {
      "captures": {
        "1": {
          "name": "constant.character.indexterm.triple.begin.asciidoc"
        },
        "3": {
          "name": "constant.character.indexterm.triple.end.asciidoc"
        }
      },
      "comment": "Triple parenthesis indexterm.\r\r\n\r\r\nExamples:\r\r\n  (((Sword, Broadsword, Excalibur)))\r\r\n\t\t\t\t",
      "match": "(?<!\\()(\\({3})([^\\(].*?)(\\){3})(?!\\))",
      "name": "variable.other.indexterm.triple.asciidoc"
    },
    "inline": {
      "patterns": [
        {
          "include": "#passthrough"
        },
        {
          "include": "#strong_double"
        },
        {
          "include": "#emphasis_double"
        },
        {
          "include": "#monospaced_double"
        },
        {
          "include": "#mark_double"
        },
        {
          "include": "#strong"
        },
        {
          "include": "#emphasis"
        },
        {
          "include": "#monospaced"
        },
        {
          "include": "#mark"
        },
        {
          "include": "#superscript"
        },
        {
          "include": "#subscript"
        }
      ]
    },
    "inline_break": {
      "comment": "Line hard break with a plus sign (+).\r\r\n\r\r\nExamples:\r\r\n  Rubies are red, +\r\r\n  Topazes are blue.\r\r\n\t\t\t\t",
      "match": "(?<=\\s)\\+$\\n?",
      "name": "constant.linebreak.asciidoc"
    },
    "inline_callout": {
      "captures": {
        "1": {
          "name": "punctuation.definition.callout.begin.asciidoc"
        },
        "2": {
          "name": "punctuation.definition.callout.end.asciidoc"
        }
      },
      "comment": "Callout label\r\r\n\r\r\nExamples:\r\r\n  <1>\r\r\n  <42>\r\r\n\t\t\t\t",
      "match": "(?<!\\\\)(<)\\d+(>)",
      "name": "constant.other.callout.asciidoc"
    },
    "inline_comment": {
      "captures": {
        "1": {
          "name": "punctuation.definition.comment.line.asciidoc"
        },
        "2": {
          "name": "meta.line.comment.content.asciidoc"
        }
      },
      "comment": "Inline comment.\r\r\n\r\r\nExamples:\r\r\n  // This is just a comment!\r\r\n\t\t\t\t",
      "match": "^(//)([^/\\n].*|)$\\n?",
      "name": "comment.line.double-slash.asciidoc"
    },
    "lines": {
      "patterns": [
        {
          "include": "#inline_comment"
        },
        {
          "include": "#list_continuation"
        },
        {
          "include": "#inline_break"
        },
        {
          "include": "#block_page_break"
        },
        {
          "include": "#block_thematic_break"
        },
        {
          "include": "#block_title"
        },
        {
          "include": "#block_id"
        },
        {
          "include": "#block_req"
        },
        {
          "include": "#section_template"
        },
        {
          "include": "#attribute_list_line"
        },
        {
          "include": "#attribute_entry"
        }
      ]
    },
    "list_continuation": {
      "match": "^\\+\\s*$\\n?",
      "name": "constant.listcontinuation.asciidoc"
    },
    "lists": {
      "comment": "My strategy for lists (and similar) is not to try to treat entire paragraphs as lists, but only call out the opening.\r\r\n\t\t\t\t",
      "patterns": [
        {
          "include": "#block_admonition_label"
        },
        {
          "include": "#ulist_item_marker"
        },
        {
          "include": "#olist_item_marker"
        },
        {
          "include": "#dlist_item_label"
        },
        {
          "include": "#colist_item_marker"
        }
      ]
    },
    "macro": {
      "captures": {
        "1": {
          "name": "markup.underline.link.macro.asciidoc"
        },
        "3": {
          "name": "keyword.control.name.macro.asciidoc"
        },
        "4": {
          "name": "constant.character.separator.macro.asciidoc"
        },
        "5": {
          "name": "markup.underline.target.macro.asciidoc"
        },
        "6": {
          "name": "constant.character.attributes.macro.begin.asciidoc"
        },
        "7": {
          "name": "variable.parameter.attributes.macro.asciidoc"
        },
        "8": {
          "name": "constant.character.attributes.macro.end.asciidoc"
        }
      },
      "comment": "Note: There are other macro notations, but I match only those that end in\r\r\nsquare brackets.\r\r\n\t\t\t\t",
      "match": "(?x)\r\r\n(?:\r\r\n  ((?:https?|mailto|ftp|file)  # specify separately so we can mark them as links that TextMate opens\r\r\n  ?:{1}  # inline only\r\r\n  \\S*)   # (others such as image are partial URLs and/or TextMate cannot handle them)\r\r\n|\r\r\n  (([a-zA-Z0-9][a-zA-Z0-9_]*)\r\r\n  (:{1,2})\r\r\n  (\\S*))\r\r\n)\r\r\n(?:(\\[)([^\\]]*)(\\]))",
      "name": "meta.macro.asciidoc"
    },
    "macro_pass": {
      "begin": "(?x) (pass) (:{1,2}) (\\S*) (\\[)(?=[^\\]]*\\])",
      "captures": {
        "1": {
          "name": "keyword.control.name.macro.pass.asciidoc"
        },
        "2": {
          "name": "constant.character.separator.macro.asciidoc"
        },
        "3": {
          "name": "markup.underline.target.macro.asciidoc"
        },
        "4": {
          "name": "constant.character.attributes.macro.begin.asciidoc"
        }
      },
      "comment": "Passthrough macro\r\r\n\r\r\nExamples:\r\r\n  pass:[Lorem ipsum]\r\r\n  pass::[Lorem ipsum]\r\r\n\t\t\t\t",
      "contentName": "variable.parameter.attributes.macro.pass.asciidoc",
      "end": "\\]",
      "endCaptures": {
        "0": {
          "name": "constant.character.attributes.macro.end.asciidoc"
        }
      },
      "name": "meta.macro.pass.asciidoc",
      "patterns": [
        {
          "include": "text.xml"
        }
      ]
    },
    "mark": {
      "captures": {
        "1": {
          "name": "support.variable.attributelist.asciidoc"
        },
        "2": {
          "name": "punctuation.definition.string.unquoted.single.begin.asciidoc"
        },
        "3": {
          "name": "punctuation.definition.string.unquoted.single.end.asciidoc"
        }
      },
      "comment": "Marked text (constrained variant).\r\r\n\r\r\nExamples:\r\r\n  #Lorem ipsum# dolor\r\r\n  [red]#Lorem ipsum# dolor\r\r\n\t\t\t\t",
      "match": "((?<![\\\\;:\\p{Word}#])(\\[[^\\]]+?\\])((#)(\\S|\\S.*?\\S)(#)(?!\\p{Word})))|((?<![\\\\;:\\p{Word}#])(\\[[^\\]]+?\\])?((#)(\\S|\\S.*?\\S)(#)(?!\\p{Word})))",
      "name": "string.other.unquoted.single.asciidoc"
    },
    "mark_double": {
      "captures": {
        "1": {
          "name": "support.variable.attributelist.asciidoc"
        },
        "2": {
          "name": "punctuation.definition.string.unquoted.double.begin.asciidoc"
        },
        "3": {
          "name": "punctuation.definition.string.unquoted.double.end.asciidoc"
        }
      },
      "comment": "Marked text (unconstrained variant).\r\r\n\r\r\nExamples:\r\r\n  Lo##re##m ##ipsum dolor##.\r\r\n  Lo[red]##re##m\r\r\n\t\t\t\t",
      "match": "((?<!\\\\\\\\)(\\[[^\\]]+?\\])((##)(.+?)(##)))|((?<!\\\\\\\\)((##)(.+?)(##)))",
      "name": "string.other.unquoted.double.asciidoc"
    },
    "monospaced": {
      "captures": {
        "1": {
          "name": "support.variable.attributelist.asciidoc"
        },
        "2": {
          "name": "punctuation.definition.literal.single.begin.asciidoc"
        },
        "3": {
          "name": "punctuation.definition.literal.single.end.asciidoc"
        }
      },
      "comment": "Monospaced text (constrained variant).\r\r\n\r\r\nExamples:\r\r\n  `Lorem ipsum` dolor\r\r\n  [red]`Lorem ipsum` dolor\r\r\n\t\t\t\t",
      "match": "(?<![\\\\;:\\p{Word}\\\"'`])(\\[.+?\\])?((`)(\\S|\\S.*?\\S)(`))(?![\\p{Word}\\\"'`])",
      "name": "string.other.literal.single.asciidoc"
    },
    "monospaced_double": {
      "captures": {
        "1": {
          "name": "support.variable.attributelist.asciidoc"
        },
        "2": {
          "name": "punctuation.definition.literal.double.begin.asciidoc"
        },
        "3": {
          "name": "punctuation.definition.literal.double.end.asciidoc"
        }
      },
      "comment": "Monospaced text (unconstrained variant).\r\r\n\r\r\nExamples:\r\r\n  Lo``re``m ``ipsum dolor``.\r\r\n  Lo[red]``re``m\r\r\n\t\t\t\t",
      "match": "(?<!\\\\)(\\[.+?\\])?((``)(.+?)(``))",
      "name": "string.other.literal.double.asciidoc"
    },
    "olist_item_marker": {
      "captures": {
        "1": {
          "name": "string.unquoted.list.dotted.asciidoc"
        },
        "2": {
          "name": "constant.numeric.list.dot.asciidoc"
        }
      },
      "comment": "Marker of an ordered (numbered) list item.\r\r\n\r\r\nExamples:\r\r\n  . level 1\r\r\n  .. level 2\r\r\n  ... level 3\r\r\n  .... level 4\r\r\n  ..... level 5\r\r\n\r\r\nNote: The space distinguishes it from a block title.\r\r\n\t\t\t\t",
      "match": "^(\\s*(\\.{1,5}))\\s+(?=\\S)",
      "name": "markup.list.numbered.dotted.asciidoc"
    },
    "passthrough": {
      "begin": "(\\+\\+\\+|\\$\\$)",
      "beginCaptures": {
        "1": {
          "name": "constant.character.passthru.begin.asciidoc"
        }
      },
      "comment": "Inline triple-plus and double dolar passthrough.\r\r\n\r\r\nExamples:\r\r\n  Lo+++re++++m +++ipsum dolor+++.\r\r\n  Lo$$re$$m $$ipsum dolor$$.\r\r\n\r\r\nNote: Must be dead first among the inlines, so as to take priority.\r\r\n\t\t\t\t",
      "contentName": "variable.parameter.passthruinner.asciidoc",
      "end": "\\1",
      "endCaptures": {
        "0": {
          "name": "constant.character.passthru.end.asciidoc"
        }
      },
      "name": "meta.passthru.inline.asciidoc"
    },
    "replacement": {
      "match": "(?x)\r\r\n(?<!\\\\)  # must not be escaped\r\r\n(\r\r\n  \\(C\\)\r\r\n  | \\(TM\\)\r\r\n  | \\(R\\)\r\r\n  | ((?<!\\-)\\-\\-(?!\\-))    # exactly two, and even this may not rule out all that I want to\r\r\n  | ((?<!\\.)\\.\\.\\.(?!\\.))  # exactly three\r\r\n  | \\->\r\r\n  | <\\-\r\r\n  | =>\r\r\n  | <=\r\r\n)",
      "name": "constant.character.replacement.asciidoc"
    },
    "section_template": {
      "captures": {
        "1": {
          "name": "punctuation.definition.sectiontemplate.begin.asciidoc"
        },
        "4": {
          "name": "meta.tag.sectiontemplate.asciidoc"
        },
        "6": {
          "name": "punctuation.definition.sectiontemplate.end.asciidoc"
        },
        "7": {
          "name": "punctuation.definition.sectiontemplate.end.asciidoc"
        }
      },
      "comment": "fixed list of known template names",
      "match": "(?x)^\r\r\n(\\[)  # in square brackets (template\\s*=\\s*)?(\")?  # might start with template-equals and might have template name in quotes\r\r\n(\r\r\nsect\\d|abstract|preface|colophon|dedication|glossary|bibliography|synopsis|appendix|index # fixed list of known templates\r\r\n)\r\r\n(\".*(\\])|(\\]))  # either close the quote (and perhaps go on) and close the bracket, or close the bracket immediately\r\r\n\\s*$\\n?\r\r\n\t\t\t\t",
      "name": "variable.parameter.sectiontemplate.asciidoc"
    },
    "section_titles": {
      "comment": "Examples:\r\r\n\r\r\n  = Document Title (Level 0)\r\r\n\r\r\n  == Level 1 Section\r\r\n\r\r\n  === Level 2 Section\r\r\n\t\t\t\t",
      "patterns": [
        {
          "include": "#title_level_5"
        },
        {
          "include": "#title_level_4"
        },
        {
          "include": "#title_level_3"
        },
        {
          "include": "#title_level_2"
        },
        {
          "include": "#title_level_1"
        },
        {
          "include": "#title_level_0"
        }
      ]
    },
    "strong": {
      "captures": {
        "1": {
          "name": "support.variable.attributelist.asciidoc"
        },
        "2": {
          "name": "punctuation.definition.bold.single.begin.asciidoc"
        },
        "3": {
          "name": "punctuation.definition.bold.single.end.asciidoc"
        }
      },
      "comment": "Strong (bold) text (constrained variant).\r\r\n\r\r\nExamples:\r\r\n  *Lorem ipsum* dolor\r\r\n  [red]*Lorem ipsum* dolor\r\r\n\t\t\t\t",
      "match": "(?<![\\\\;:\\p{Word}\\*])(\\[.+?\\])?((\\*)(\\S|\\S.*?\\S)(\\*)(?!\\p{Word}))",
      "name": "markup.bold.single.asciidoc"
    },
    "strong_double": {
      "captures": {
        "1": {
          "name": "support.variable.attributelist.asciidoc"
        },
        "2": {
          "name": "punctuation.definition.bold.double.begin.asciidoc"
        },
        "3": {
          "name": "punctuation.definition.bold.double.end.asciidoc"
        }
      },
      "comment": "Strong (bold) text (unconstrained variant).\r\r\n\r\r\nExamples:\r\r\n  Lo**re**m **ipsum dolor**.\r\r\n  Lo[red]**re**m\r\r\n\t\t\t\t",
      "match": "(?<!\\\\\\\\)(\\[.+?\\])?((\\*\\*)(.+?)(\\*\\*))",
      "name": "markup.bold.double.asciidoc"
    },
    "subscript": {
      "captures": {
        "1": {
          "name": "support.variable.attributelist.asciidoc"
        },
        "2": {
          "name": "punctuation.definition.string.subscript.begin.asciidoc"
        },
        "3": {
          "name": "punctuation.definition.string.subscript.end.asciidoc"
        }
      },
      "comment": "Subscript text.\r\r\n\r\r\nExamples:\r\r\n  H~2~O\r\r\n  H[red]~2~O\r\r\n\t\t\t\t",
      "match": "(?<!\\\\)(\\[.+?\\])?((~)(\\S+?)(~))",
      "name": "string.other.subscript.asciidoc"
    },
    "superscript": {
      "captures": {
        "1": {
          "name": "support.variable.attributelist.asciidoc"
        },
        "2": {
          "name": "punctuation.definition.string.superscript.begin.asciidoc"
        },
        "3": {
          "name": "punctuation.definition.string.superscript.end.asciidoc"
        }
      },
      "comment": "Superscript text.\r\r\n\r\r\nExamples: E=mc^2^ E=mc[red]^2^\r\r\n\t\t\t\t",
      "match": "(?<!\\\\)(\\[.+?\\])?((\\^)(\\S+?)(\\^))",
      "name": "string.other.superscript.asciidoc"
    },
    "title_level_0": {
      "captures": {
        "1": {
          "name": "punctuation.definition.heading.asciidoc"
        },
        "2": {
          "name": "entity.name.section.asciidoc"
        }
      },
      "match": "^(=) (\\S.*)$\\n?",
      "name": "markup.heading.level.0.asciidoc"
    },
    "title_level_1": {
      "captures": {
        "1": {
          "name": "punctuation.definition.heading.asciidoc"
        },
        "2": {
          "name": "entity.name.section.asciidoc"
        }
      },
      "match": "^(==) (\\S.*)$\\n?",
      "name": "markup.heading.level.1.asciidoc"
    },
    "title_level_2": {
      "captures": {
        "1": {
          "name": "punctuation.definition.heading.asciidoc"
        },
        "2": {
          "name": "entity.name.section.asciidoc"
        }
      },
      "match": "^(===) (\\S.*)$\\n?",
      "name": "markup.heading.level.2.asciidoc"
    },
    "title_level_3": {
      "captures": {
        "1": {
          "name": "punctuation.definition.heading.asciidoc"
        },
        "2": {
          "name": "entity.name.section.asciidoc"
        }
      },
      "match": "^(====) (\\S.*)$\\n?",
      "name": "markup.heading.level.3.asciidoc"
    },
    "title_level_4": {
      "captures": {
        "1": {
          "name": "punctuation.definition.heading.asciidoc"
        },
        "2": {
          "name": "entity.name.section.asciidoc"
        }
      },
      "match": "^(=====) (\\S.*)$\\n?",
      "name": "markup.heading.level.4.asciidoc"
    },
    "title_level_5": {
      "captures": {
        "1": {
          "name": "punctuation.definition.heading.asciidoc"
        },
        "2": {
          "name": "entity.name.section.asciidoc"
        }
      },
      "match": "^(======) (\\S.*)$\\n?",
      "name": "markup.heading.level.5.asciidoc"
    },
    "ulist_item_marker": {
      "captures": {
        "1": {
          "name": "string.unquoted.list.bullet.asciidoc"
        },
        "2": {
          "name": "constant.numeric.list.bullet.asciidoc"
        }
      },
      "comment": "Marker of an unordered (bullet) list item.\r\r\n\r\r\nExamples:\r\r\n  * level 1\r\r\n  ** level 2\r\r\n  *** level 3\r\r\n  **** level 4\r\r\n  ***** level 5\r\r\n  - level 1\r\r\n  -- level 2\r\r\n  --- level 3\r\r\n  ---- level 4\r\r\n  ----- level 5\r\r\n\t\t\t\t",
      "match": "^(\\s*(\\-|\\*{1,5}))\\s+(?=\\S)",
      "name": "markup.list.bulleted.asciidoc"
    },
    "xref": {
      "captures": {
        "1": {
          "name": "constant.character.xref.begin.asciidoc"
        },
        "2": {
          "name": "markup.underline.term.xref.asciidoc"
        },
        "5": {
          "name": "variable.parameter.xref.asciidoc"
        },
        "6": {
          "name": "constant.character.xref.end.asciidoc"
        }
      },
      "comment": "Internal cross-reference\r\r\n\r\r\nExamples:\r\r\n  <<lorem>>\r\r\n  <<lorem, see here>>\r\r\n\t\t\t\t",
      "match": "(?<!<)(<<)([^,]*?)((,\\s*)(.*?))?(>>)(?!<)",
      "name": "meta.xref.asciidoc"
    }
  },
  "scopeName": "text.asciidoc",
  "uuid": "A2AE6D21-3F08-4978-ADF3-55B5AD580921"
}